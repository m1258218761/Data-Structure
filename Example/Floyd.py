#coding=utf-8
'''Floyd-warshall(佛洛依德)算法，是求任意两点间的最短路径的一种算法。通常可以在任何图中使用，包括有向图、带负权边的图。
如果要让任意两个点（例如从顶点a到顶点b）之间的路程变短，只能引入第三个点（顶点k），通过这个顶点k中转，即a->k->b，才有可能缩短原来从顶点a到顶点b的路程。
有些时候甚至不只通过一个中转点，而是经过两点中转点或者更多，即a->k1->k2->b或者a->k1->k2->k3->......->b，使得从顶点a到顶点b的路径更短。'''

# 字典的第1个键为起始节点，第2个键为目标节点，其键值为两个节点间的直接距离
# 将不相连点设为INF,方便更新两点之间的最小值
INF = 99999
G = {1:{1:0,    2:2,    3:6,    4:4},
     2:{1:INF,  2:0,    3:3,    4:INF},
     3:{1:7,    2:INF,  3:0,    4:1},
     4:{1:5,    2:INF,  3:12,   4:0}
     }

# 算法思想：
# 每个顶点都有可能使得两个顶点之间的距离变短
# 当两点之间不允许有第三个点时，这些城市之间的最短路径就是初始路径

# Floyd-Warshall算法核心语句
# 分别在只允许经过某个点k的情况下，更新点和点之间的最短路径
def floyd(G):
    for k in G.keys():      # 不断试图往两点i,j之间添加新的点k，更新最短距离
        for i in G.keys():
            for j in G[i].keys():
                if G[i][j] > G[i][k] + G[k][j]:
                    G[i][j] = G[i][k] + G[k][j]
    return G

if __name__ == '__main__':
    G = floyd(G)
    for i in G.keys():
        print(G[i].values())